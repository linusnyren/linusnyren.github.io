{"version":3,"sources":["components/Camera.js","App.js","serviceWorker.js","index.js"],"names":["Camera","videoSrc","useRef","useState","updateRate","setUpdateRate","mood","setMood","age","setAge","gender","setGender","useEffect","loadModels","video","document","getElementsByClassName","setAttribute","console","log","startVideo","a","navigator","mediaDevices","getUserMedia","then","stream","handleVideo","catch","videoError","err","alert","current","srcObject","handleFaces","displaySize","width","height","faceapi","setInterval","withFaceExpressions","withAgeAndGender","detections","handleExpression","Promise","all","tinyFaceDetector","loadFromUri","faceLandmark68Net","faceRecognitionNet","faceExpressionNet","ageGenderNet","det","expressions","toFixed","currentmood","Object","keys","reduce","b","className","color","autoPlay","muted","playsInline","ref","onChange","value","distance","min","max","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.2e4095aa.chunk.js","sourcesContent":["import React,{useState,useEffect, useRef} from 'react'\nimport * as faceapi from 'face-api.js'\nimport { NeuDiv, NeuSlider } from \"neumorphism-react\";\nimport ReactDOM from 'react-dom'\nimport './Camera.css'\nexport default function Camera() {\n    const videoSrc = useRef()\n    const [updateRate, setUpdateRate] = useState(500)\n    const [mood, setMood] = useState(null)\n    const [age, setAge] = useState(null)\n    const [gender, setGender] = useState(null)\n    useEffect(()=>{\n        loadModels()\n        let video = document.getElementsByClassName(\"video\")[0]\n        video.setAttribute('autoplay', '');\n        video.setAttribute('muted', '');\n        video.setAttribute('playsinline', '');\n        console.log(video)\n    },[])\n    const startVideo=async()=> {\n        try{\n            let stream = navigator.mediaDevices\n            stream\n            .getUserMedia({video: true})\n            .then(stream => handleVideo(stream))\n            .catch(videoError);\n        }\n        catch(err){\n            console.log(err)\n            alert(\"device not supported\")\n            alert(err)\n        }\n      }\n\n    const handleVideo=(stream)=> {\n      // Update the state, triggering the component to re-render with the correct stream\n      videoSrc.current.srcObject = stream\n      handleFaces()\n    }\n    const videoError=(err)=> {\n        alert(err)\n    }\n    const handleFaces=async()=>{\n        const displaySize = { width: videoSrc.current.width, height: videoSrc.current.height }\n        faceapi.matchDimensions(displaySize, displaySize)\n        setInterval(async () => {\n            const detections = await faceapi.detectSingleFace(videoSrc.current, \n                new faceapi.TinyFaceDetectorOptions()).withFaceExpressions().withAgeAndGender()\n            if(detections){\n                console.log(detections)\n                handleExpression(detections)\n            }\n          }, updateRate)\n    }\n    const loadModels=async()=>{\n        console.log(\"loading models\")\n        try{\n        return Promise.all([\n            faceapi.nets.tinyFaceDetector.loadFromUri('./models'),\n            faceapi.nets.faceLandmark68Net.loadFromUri('./models'),\n            faceapi.nets.faceRecognitionNet.loadFromUri('./models'),\n            faceapi.nets.faceExpressionNet.loadFromUri('./models'),\n            faceapi.nets.ageGenderNet.loadFromUri('./models')\n          ]).then(startVideo)\n        }\n        catch(err){\n            alert(err)\n        }\n    }\n    const handleExpression=(det)=>{\n        const {expressions, gender, age} = det\n        setAge(age.toFixed(0))\n        setGender(gender)\n        var currentmood = Object.keys(expressions).reduce((a, b) => expressions[a] > expressions[b] ? a : b);\n        setMood(currentmood)\n    }\n      return (\n          <div className=\"mainContainer\">\n                <NeuDiv className=\"containerDiv\" color=\"#477854\" >\n                    <h3 className=\"resultText\">\n                      {mood ? \"You look like youÂ´re an \"+mood+\" \"+age+\" year old \"+gender\n                      :\n                      \"Analysing your face\"}\n                    </h3>\n                </NeuDiv>\n                <NeuDiv className=\"containerDiv\" width=\"auto\" height=\"auto\" color=\"#477854\">\n                    <video\n                        autoPlay\n                        muted={true}\n                        playsInline\n                        className=\"video\"\n                        ref={videoSrc}\n                        autoPlay={true}\n                    />\n                </NeuDiv>\n                <NeuDiv className=\"containerDiv\" color=\"#477854\">\n                    <h5>Adjust the detection rate</h5>\n                        <NeuSlider\n                          color=\"#477854\"\n                          className=\"sliderBar\"\n                          onChange={(value) => setUpdateRate(value)}\n                          distance={2}\n                          min={100}\n                          max={5000}\n                        />\n                        <h4>{updateRate/1000}s</h4>\n                </NeuDiv>\n        </div>\n        )\n    }\n/*\nexport class WebcamStream extends React.Component {\n    constructor(props) {\n        super(props);\n        this.videoTag = React.createRef()\n    }\n\n    componentDidMount() {\n        // getting access to webcam\n       navigator.mediaDevices\n            .getUserMedia({video: true})\n            .then(stream => this.videoTag.current.srcObject = stream)\n            .catch(console.log);\n    }\n\n    render() {\n        return <video id={this.props.id}\n                      ref={this.videoTag}\n                      width={this.props.width}\n                      height={this.props.height}\n                      autoPlay\n                      title={this.props.title}></video>\n    }\n*/","import React from 'react';\nimport Camera from './components/Camera'\nfunction App() {\n  return (\n    <Camera/>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}